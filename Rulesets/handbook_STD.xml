<?xml version="1.0" encoding="UTF-8"?>
<hb:RuleSet xmlns:hb="HANDBOOK"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="HANDBOOK ../XSD/handbook.xsd ">
	<hb:Rule UID="STD_00100">
		<hb:RuleUID>STD_00100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>VHDL object naming convention</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>VHDL Object naming convention improves readability and reuse.</hb:Rationale>
			<hb:ShortDesc>VHDL Object name definition uses an unique and specific naming convention.</hb:ShortDesc>
			<hb:LongDesc>This convention can address the naming of any VHDL objects like signals, variables, constants, generic, labels, modules, entity, etc.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_00200">
		<hb:RuleUID>STD_00200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Name of clock signal</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_00100</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>The clock signal is critical. This signal needs to be easily found through the design.</hb:Rationale>
			<hb:ShortDesc>The clock signal name includes "clk" or "clock".</hb:ShortDesc>
			<hb:LongDesc>A signal is considered as a "CLOCK" whenever it is used to synchronize other signals to its rising or falling edge within a synchronous process with one of the following VHDL functions ('event, rising_edge or falling_edge), or when it is mapped on an IP clock input.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Confusing</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_00200_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_00200_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure ></hb:Figure>
		</hb:RuleDesc>
		<hb:RuleParams>
			<hb:StringParam>
				<hb:ParamID>P1</hb:ParamID>
				<hb:Position>Contain</hb:Position>
				<hb:Value>clk</hb:Value>
			</hb:StringParam>
			<hb:StringParam>
				<hb:ParamID>P2</hb:ParamID>
				<hb:Position>Contain</hb:Position>
				<hb:Value>clock</hb:Value>
			</hb:StringParam>
		</hb:RuleParams>
	</hb:Rule>
	
	<hb:Rule UID="STD_00300">
		<hb:RuleUID>STD_00300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>7</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Name of reset signal</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_00100</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>The reset signal is critical. This signal needs 
			to be easily found through the design.</hb:Rationale>
			<hb:ShortDesc>The reset signal name includes "rst", "reset" or "clr".</hb:ShortDesc>
			<hb:LongDesc>A signal is considered as a "RESET" whenever it is used inside a clocked-process to initialize signals value to a known state (most of the time zero) or mapped on a IP reset input.
If several reset signals are used, each reset is identified with a different name.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Confusing</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_00300_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_00300_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
		<hb:RuleParams>
			<hb:StringParam>
				<hb:ParamID>P1</hb:ParamID>
				<hb:Position>Contain</hb:Position>
				<hb:Value>reset</hb:Value>
			</hb:StringParam>
			<hb:StringParam>
				<hb:ParamID>P2</hb:ParamID>
				<hb:Position>Contain</hb:Position>
				<hb:Value>rst</hb:Value>
			</hb:StringParam>
			<hb:StringParam>
				<hb:ParamID>P3</hb:ParamID>
				<hb:Position>Contain</hb:Position>
				<hb:Value>clr</hb:Value>
			</hb:StringParam>
		</hb:RuleParams>
	</hb:Rule>
	
	<hb:Rule UID="STD_00400">
		<hb:RuleUID>STD_00400</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Label for process</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_00100</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Labels improve readability of simulations, VHDL source code and synthesis logs.</hb:Rationale>
			<hb:ShortDesc>Processes are identified by a label.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_00400_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_00400_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_00400_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_00400_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_00500">
		<hb:RuleUID>STD_00500</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Name of signal relation with behaviour</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_00100</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>A signal name related to its function improves the understanding of the code. It avoids miscomprehension by a peer reader and thus improves reliability of the code.</hb:Rationale>
			<hb:ShortDesc>The signal name clearly identifies its purpose.</hb:ShortDesc>
			<hb:LongDesc>A signal name is related to its functionality.
For example a control signal (chip-select, write enable, read/output enable), an address, a counter, an enable, a pulse, a flag, acknowledge, ...</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Confusing</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_00600">
		<hb:RuleUID>STD_00600</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>VHDL file extension</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Same extension for each source file improves search and scripted automated actions.</hb:Rationale>
			<hb:ShortDesc>The extension of VHDL source file is .vhd</hb:ShortDesc>
			<hb:LongDesc>The extension of the VHDL file is ".vhd". The extension ".v" is reserved for the Verilog language. 
The extension ".vhdl" is not permitted.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>Trivial</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_00700">
		<hb:RuleUID>STD_00700</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Deleted</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Preservation of signal name</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>There is no need to change a signal name if this signal isn't modified.
Renaming important signals (like clock or reset) can lead to simulation mismatch. 
Moreover, changing a signal name which is not altered makes the understanding of the code more difficult.</hb:Rationale>
			<hb:ShortDesc>A non modified signal keeps its name through hierarchy levels.</hb:ShortDesc>
			<hb:LongDesc>Important signals like reset or clock have to keep their name across hierarchy. 
It is best practice for other signals not to change their name if they are not altered by any kind of logic.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Confusing</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_00701">
		<hb:RuleUID>STD_00701</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>3</hb:Version>
			<hb:Creation>2015-07-31</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Preservation of signal name inside an entity</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>There is no need to change a signal name if this signal isn't modified.
Renaming important signals (like clock or reset) can lead to simulation mismatch.
Moreover, changing a signal name which is not altered makes the understanding of the code more difficult.</hb:Rationale>
			<hb:ShortDesc>A non-modified signal keeps its name within its entity.</hb:ShortDesc>
			<hb:LongDesc>Critical signals like reset or clock have to keep their name. 
			It is best practice not to change signals name if they are not altered by any kind of logic. They should also keep their meaning (e.g. an enable should contain "en", a write "wr" etc.)</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_00800">
		<hb:RuleUID>STD_00800</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>File name convention</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>File name coherence improves search and scripted automated actions.</hb:Rationale>
			<hb:ShortDesc>File name uses an unique and specific naming convention within a design.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Trivial</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_00900">
		<hb:RuleUID>STD_00900</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>File name of an entity</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_00800</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>Naming</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>The match between file name and entity name improves the search for an entity inside a project.</hb:Rationale>
			<hb:ShortDesc>The file name for an entity VHDL file includes at least the entity name.</hb:ShortDesc>
			<hb:LongDesc>File name of an entity called MyEntity is :
			
				(Any characters)MyEntity(Any characters).vhd</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Trivial</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
		<hb:Rule UID="STD_01000">
		<hb:RuleUID>STD_01000</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Number of entities per file</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>A single entity by file avoids compilation or synthesis ordering problems. It improves search for the file including a specific entity.</hb:Rationale>
			<hb:ShortDesc>Each source file contains only one VHDL entity.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_01100">
		<hb:RuleUID>STD_01100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Number of architectures in files</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>When the design is synthesized, only one architecture is synthesized for each synthesized entity. Including only one architecture per file reduces a potential architecture selection error at synthesis level.</hb:Rationale>
			<hb:ShortDesc>Each VHDL file includes only one architecture per file.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>

	</hb:Rule>
	<hb:Rule UID="STD_01200">
		<hb:RuleUID>STD_01200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Number of statements per line</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>A single statement per line improves readability and maintainability.</hb:Rationale>
			<hb:ShortDesc>Each line includes only one statement.</hb:ShortDesc>
			<hb:LongDesc>A statement could be an affectation sequence, a conditional test, a declaration or a VHDL beginning sequence like case, process...).</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_01200_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_01200_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_01200_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_01200_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_01300">
		<hb:RuleUID>STD_01300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Number of ports declaration per line</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>A single port declaration per line improves readability.</hb:Rationale>
			<hb:ShortDesc>Each line includes only one port definition or mapping.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_01300_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_01300_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_01300_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_01300_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_01400">
		<hb:RuleUID>STD_01400</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Instantiation of components</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Instantiation by name improves readability as there is not need to look to the entity definition to know the connection between port and signal.
It reduces risks of inconsistency between the entity definition and the component instantiation in case of entity modification.
			</hb:Rationale>
			<hb:ShortDesc>The instantiation of components is made by name.</hb:ShortDesc>
			<hb:LongDesc>Since instantiation is made by name, the instantiation by position is prohibited.
This rule does not apply to instantiations made within IP cores would they be coming auto generated from a tool or provided by any IP core provider.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_01400_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_01400_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_01400_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_01400_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>

	</hb:Rule><hb:Rule UID="STD_01500">
		<hb:RuleUID>STD_01500</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Entity ports convention</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Ports declaration strategy allows readability and reuse.</hb:Rationale>
			<hb:ShortDesc>Entity ports are organized with a dedicated convention.</hb:ShortDesc>
			<hb:LongDesc>This convention deals with the way the ports of an entity are sorted: by direction, interface, special signals...</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_01600">
		<hb:RuleUID>STD_01600</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Entity port sort</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_01500</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Ports grouped by external interfaces improves readability.</hb:Rationale>
			<hb:ShortDesc>Entity ports are organized by interface.</hb:ShortDesc>
			<hb:LongDesc>Entity ports are grouped by external interfaces.
Within an interface group, ports could then be sorted by direction (input, output, bidirectional).</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_01600_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_01600_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_01600_bad.vhd</hb:BadExDesc>
			<hb:BadExample>STD_01600_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>

	</hb:Rule><hb:Rule UID="STD_01700">
		<hb:RuleUID>STD_01700</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Entity special ports</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_01500</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>These special signals are important for the understanding of the module functionalities. Thus gathering them at the beginning of an entity improves readability.</hb:Rationale>
			<hb:ShortDesc>Special ports are the first group of an entity.</hb:ShortDesc>
			<hb:LongDesc>Special input ports like clock(s), reset and global enable are the first to be written in an entity.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_01700_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_01700_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_01700_bad.vhd</hb:BadExDesc>
			<hb:BadExample>STD_01700_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_01800">
		<hb:RuleUID>STD_01800</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Primitive isolation</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Specific or primitive IP cores are technology dependent. Isolating these IP improves technology retargeting.</hb:Rationale>
			<hb:ShortDesc>Primitive are isolated in a wrapper entity defined in a dedicated VHDL file.</hb:ShortDesc>
			<hb:LongDesc>When an IP core is used (memory inference/instantiation, primitives instantiations like PLLs, etc), then the generated HDL code is manufacturer/technology specific.
It is best practice to separate this code from the general HDL code, which is not specific to the manufacturer/technology, by creating a	more generic wrapper which contains all those specific HDL codes.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_01900">
		<hb:RuleUID>STD_01900</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Indentation of source code</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Proper indentation improves readability.</hb:Rationale>
			<hb:ShortDesc>VHDL source file is indented.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Info</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_01900_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_01900_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_01900_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_01900_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02000">
		<hb:RuleUID>STD_02000</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Indentation style</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_01900</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Text editors display hard tabs differently. When a designer uses only spaces, the sources code formatting is independent of the text editor used.</hb:Rationale>
			<hb:ShortDesc>Indentation is made by a fixed number of blank spaces instead of tabulation.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Trivial</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>

	<hb:Rule UID="STD_02100">
		<hb:RuleUID>STD_02100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Compactness of VHDL source code</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Formatting</hb:Category>
			<hb:SubCategory>FileStructure</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Hand coded VHDL source files limited in size keeps the module less complicated and thus easier to validate and read.
Moreover, some tools do not handle well too many characters per lines.</hb:Rationale>
			<hb:ShortDesc>Hand coded VHDL source files are limited in size.</hb:ShortDesc>
			<hb:LongDesc>File limitation strategy might be implemented with a limit of lines, name characters, entity's names length, compact signal name, etc. </hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02200">
		<hb:RuleUID>STD_02200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Version control in header of file</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Versioning</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Version control ensures that development history is saved so that a new developer could use it and avoid previous mistakes or understand previous choices.
Understanding the last modifications allows integrator to know if a bug was corrected or if the modification will produce a problem.</hb:Rationale>
			<hb:ShortDesc>VHDL file includes information that tracks and provides control over changes to source code.</hb:ShortDesc>
			<hb:LongDesc>The revision control mechanism is written in the header file which then includes:
			  - Version Tag (number, letter...),
			  - Author,
			  - Date of modification,
			  - Author of modification,
			  - Description of modification,
			  - Reason of modification,
			  - Impacts of modification,
			  - The file creation date,
			  - Current version number.
Large VHDL project could use version control software (like SVN). If this is the case a tag identifying the version is also included.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_02200_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_02200_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_02200_bad.vhd</hb:BadExDesc>
			<hb:BadExample>STD_02200_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02300">
		<hb:RuleUID>STD_02300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Copyright information in the header of file</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Versioning</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>These information ensure that the VHDL file is not reused or disclosed if it is not allowed.</hb:Rationale>
			<hb:ShortDesc>Header of the file includes copyright information.</hb:ShortDesc>
			<hb:LongDesc>The copyright information includes:
			  - A license restriction (if needed),
			  - The name of the company owning the rights,
			  - The VHDL designer company if the design is subcontracted.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Security</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02400">
		<hb:RuleUID>STD_02400</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-12-01</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Creation information in the header of the file</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Versioning</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>A common header format which gathers all important information for each HDL file improves the understanding of VHDL background context of the developed module.</hb:Rationale>
			<hb:ShortDesc>HDL file includes a header with specific information.</hb:ShortDesc>
			<hb:LongDesc>Typical information that can be included in the header are: file name, author, creation date, project name, software context.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02500">
		<hb:RuleUID>STD_02500</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>3</hb:Version>
			<hb:Creation>2014-12-01</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Functional information in the header of file</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Versioning</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Functional information in the file header improves understanding of the code function while reviewing or reusing it.</hb:Rationale>
			<hb:ShortDesc>Header of file includes information about code functionality.</hb:ShortDesc>
			<hb:LongDesc>Functional description could be, for example, a short description of the file functions, its limitations or a description of the naming convention used.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02600">
		<hb:RuleUID>STD_02600</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>IEEE libraries preference</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Reuse</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Using libraries standardized by the IEEE improves code portability.
"std_logic_arith", "std_logic_signed" and "std_logic_unsigned" libraries are not standardized.</hb:Rationale>
			<hb:ShortDesc>Use the following IEEE libraries : "std_logic_1164" and "numeric_std"</hb:ShortDesc>
			<hb:LongDesc>Do not use deprecated Synopsys libraries "std_logic_arith", "std_logic_signed" and "std_logic_unsigned" except if you are targeting specifically a Synopsys synthesizer (like for an ASIC for instance).
Nevertheless, never mix these two library families.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>

	<hb:Rule UID="STD_02700">
		<hb:RuleUID>STD_02700</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Default language</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Reuse</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>English language usage allows readability and reuse by a broader group (including an international designer community).</hb:Rationale>
			<hb:ShortDesc>Header, instructions and comments are written in English.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02800">
		<hb:RuleUID>STD_02800</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Comment strategy</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Reuse</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Relevant comments increase readability of the code.</hb:Rationale>
			<hb:ShortDesc>The VHDL code includes comments.</hb:ShortDesc>
			<hb:LongDesc>The VHDL code comments need to explain the purposes and objectives of the code as much as possible, but should not describe it.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_02900">
		<hb:RuleUID>STD_02900</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Comments for entity ports</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_02800</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Reuse</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Comments on ports allow the IP integrator to quickly identify port connections when instantiating the modules.</hb:Rationale>
			<hb:ShortDesc>Each entity port is commented with a short functional description.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_02900_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_02900_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_02900_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_02900_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03000">
		<hb:RuleUID>STD_03000</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Comments for objects declaration and statements</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_02800</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Reuse</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Accurate and up-to-date comments increase readability, reusability and understanding</hb:Rationale>
			<hb:ShortDesc>Each process, group of instructions and objects declaration are commented</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>User-experience</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03000_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03000_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_03000_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_03000_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>

	<hb:Rule UID="STD_03100">
		<hb:RuleUID>STD_03100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Dead VHDL code</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Traceability</hb:Category>
			<hb:SubCategory>Requirement</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Deleting unnecessary portions of code improve code coverage results and make the design more robust.</hb:Rationale>
			<hb:ShortDesc>Unnecessary portions of code are deleted</hb:ShortDesc>
			<hb:LongDesc>Unused declared signals and constants are deleted. Inactive or wrong code is deleted. Pieces of code commented out doesn't appear in HDL sources.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Vulnerability</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Suspicious</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03100_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03100_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_03100_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_03100_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03200">
		<hb:RuleUID>STD_03200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unused output ports components management</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>I/O</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>The keyword "open" is preferred to the connection of an unused output port to a dummy signal which causes implicit net connection during synthesis.</hb:Rationale>
			<hb:ShortDesc>Unused output ports are mapped with the keyword "open".</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Pittfall</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03200_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03200_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_03200_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_03200_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03300">
		<hb:RuleUID>STD_03300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Buffer port type</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>I/O</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>VHDL authorize entity I/O to be of type in, out, inout or buffer. Buffer authorizes an output of an entity to be read inside the entity.
Manufacturers of synthesis software do not recommend "buffer" type usage because buffers may give some problems during synthesis.</hb:Rationale>
			<hb:ShortDesc>"Buffer" port in an entity is forbidden.</hb:ShortDesc>
			<hb:LongDesc>Reading an output signal inside an entity can be achieved by creating an internal signal.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Pittfall</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03300_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03300_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_03300_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_03300_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03400">
		<hb:RuleUID>STD_03400</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Top level ports</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>I/O</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Top level entity ports are mapped on real component pins. Thus, restrictions apply to be sure that these VHDL pins map flawlessly to real pins.</hb:Rationale>
			<hb:ShortDesc>Top level ports include approved types.</hb:ShortDesc>
			<hb:LongDesc>When designing the TOP level, the designer uses only types which are allowed. Every types which are not in the allowed list are prohibited to use.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03500">
		<hb:RuleUID>STD_03500</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Record type for top level entity ports</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_03400</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>I/O</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Top level entity ports are mapped on real component pins. Thus, restrictions apply to be sure that these VHDL pins map flawlessly to real pins.</hb:Rationale>
			<hb:ShortDesc> Record type is forbidden for top level entity ports.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03600">
		<hb:RuleUID>STD_03600</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Reset sensitive level</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>FPGA</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Reset</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>In a FPGA, the reset signal is usually a high fan-out signal routed using a dedicated global signal routing track. Using both levels of the reset signal to asynchronously reset the flip-flops of the design results in the synthesis of the reset signal itself and its inverted version, which leads to the usage of 2 global dedicated routing tracks versus a single one, with one of the reset signal passing through an inverter in the FPGA fabric rendering the reset recovery timings closure harder to meet for the FPGA EDA tools.</hb:Rationale>
			<hb:ShortDesc>Every synchronous process uses the same reset	activation level.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03600_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03600_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_03600_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_03600_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03700">
		<hb:RuleUID>STD_03700</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>7</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Reset assertion and deassertion</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Reset</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Synchronous design uses the principle that all registers in a same clock domain leave the reset state at the same time. 
Asynchronous assertion ensures that the design could be reset even if the input clock is not yet functional.
Synchronous deassertion ensures that the component startup sequence is reproducible and that the clock is ready and stable before the deassertion of the reset inside the component.
Doing so, if there is a glitch on the external reset, it will produce an internal reset that is active at least one clock period and guarantees a correct reset of the internal logic.
</hb:Rationale>
			<hb:ShortDesc>Internal reset is asserted asynchronously and deasserted synchronously.</hb:ShortDesc>
			<hb:LongDesc>If several clock domains are used then several reset signals are created to be deasserted synchronously with each targeted clock domain.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03700_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03700_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_03700.svg" height="250px"
				width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03800">
		<hb:RuleUID>STD_03800</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Synchronous elements initialization</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>FPGA</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Reset</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Initialization of synchronous elements contribute to deterministic reset behaviour and simulation match between functional and Post-Place and Route.</hb:Rationale>
			<hb:ShortDesc>All synchronous elements (such as registers, counters and FSM states...) are initialized by a reset.</hb:ShortDesc>
			<hb:LongDesc>Sometimes special features do not stand for reset (like datapath, divisor, MAC IP...), this have to be justified.

For example, if all sequencing registers are reset, it is not mandatory to reset registers of the datapath.
Indeed, manufacturers recommend removing resets or changing them to synchronous where possible.
Benefits of removing resets :
- Fewer timing paths
- Performance
- Routing
- Inferencing
Benefits of changing resets to synchronous :
- Improved use of dedicated register functions
- More flexible register placement
- More predictable timing and circuit operation</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03800_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03800_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_03800_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_03800_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_03900">
		<hb:RuleUID>STD_03900</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>Yosys-ghdl</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>State machine type definition</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>StateMachine</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Enumerated type to encode FSM states allows readability and reuse.</hb:Rationale>
			<hb:ShortDesc>FSM states are encoded using enumerated type.</hb:ShortDesc>
			<hb:LongDesc>Other type of state machine definition like vectors or integer are forbidden.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_03900_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_03900_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_03900_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_03900_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04000">
		<hb:RuleUID>STD_04000</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>State machine case enumeration completion</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>StateMachine</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>State completion ensures deterministic behaviour between simulation and final design.</hb:Rationale>
			<hb:ShortDesc>VHDL code addresses all the defined states of the state machine.</hb:ShortDesc>
			<hb:LongDesc>When all cases statement are not explicitly addressed in the VHDL code, an extra "when others" case will be added.
"when others" instruction handles the default condition when none of the previous case statements are met.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_04000_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_04000_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_04000_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_04000_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04100">
		<hb:RuleUID>STD_04100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Clock domain crossing</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Changing clock domains can lead to data incoherency or data loss due to metastability. These effects will mainly be seen on the integrated system. 
The use of a validated clock domain change mechanism reduces the risk of discrepancies.</hb:Rationale>
			<hb:ShortDesc>All data exchanges between different clock domains are done with specific approved mechanism.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04200">
		<hb:RuleUID>STD_04200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Clock domain crossing handshake based</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_04100</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Note</hb:Severity>
			<hb:Rationale>Using the proper clock domain crossing technique to pass a data bus from one clock domain to another is critical in order to ensure a proper behaviour of the design under any circumstances.
When the data to synchronize is a data bus or can be considered as one, and that the high latency of the handshake based synchronizer can be tolerated, then dual handshake synchronizer technique is appropriate.</hb:Rationale>
			<hb:ShortDesc>Clock domain crosses uses a handshake based synchronizer.</hb:ShortDesc>
			<hb:LongDesc>In the source clock domain, when the source data is ready for synchronization, a "transmit request" control signal is activated. The source data stability has to be guaranteed until reception of a "receipt acknowledge".
In the destination clock domain, the "transmit request" control signal is synchronized using a double or triple register synchronization technique.
It is then used to sample the data to synchronize in the destination clock domain. A "receipt acknowledge" is then sent back to the source clock domain. In the source clock domain, the "receipt acknowledge" is synchronized using a double or triple register synchronization technique.
The source data can now be changed and another synchronization handshake can be initiated.
"transmit request" and "receipt acknowledge" data stability for the m-registers synchronizers:
			  - data values must be stable for m+1 destination clock cycles.
Source data stability:
			  - The source data must be present when "transmit request" is asserted	on the destination and remain stable until the "receipt acknowledge" is generated.
The source clock domain should continue to assert the "transmit request" control signal until "receipt acknowledge" is asserted at the source clock domain.
The sender should not assert a new "transmit request" until the acknowledgement for the previous transfer is deasserted in the source clock domain.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_04200_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_04200_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample></hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_04200.svg" height="450px" width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04300">
		<hb:RuleUID>STD_04300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Clock domain crossing FIFOs based</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_04100</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Note</hb:Severity>
			<hb:Rationale>Using the proper clock domain crossing technique to pass a data bus from one clock domain to another is critical in order to ensure a proper behaviour of the design under any circumstances.
When the data to synchronize is a data bus or can be considered as one, that the synchronization rate is fast, and that the high latency of a handshake based synchronizer cannot be tolerated, then dual clock FIFO synchronizer technique (if available in the component) is appropriate.
The FIFO implementation ensures data order and data content preservation.</hb:Rationale>
			<hb:ShortDesc>Clock domain crossing uses a dual clock FIFO based synchronizer.</hb:ShortDesc>
			<hb:LongDesc>There are many "dual clock FIFO synchronizer" implementation variations. The FIFO size has to be carefully chosen to cope with clock frequencies differences, read and write rates, read and write methods (continuous vs burst).
As a general rule, the data is written into a dual-port RAM block from the source clock domain and the RAM is read in the destination clock domain.
Gray-coded read and write pointers are passed into the alternate clock domain (using two m-registers synchronizers) to generate the following most common status flags:
			- FIFO full: all available memory locations of the FIFO are used. No write can be applied to the FIFO.
			- FIFO empty: There is no data available in the FIFO. No read can be applied to the FIFO.
			- FIFO underflow: a FIFO read was issued while the FIFO was empty. A FIFO reset is now required to recover from that state unless auto FIFO underflow recovery was designed and enabled.
			- FIFO overflow: a FIFO write was issued while the FIFO was full. A FIFO reset is now required to recover from that state unless auto FIFO overflow recovery was designed and enabled.
The following status flags can also be made available:
			- FIFO almost full: FIFO is becoming full. The number of available elements in the FIFO is above a given threshold.
			- FIFO almost empty: FIFO is becoming empty. The number of available elements in the FIFO is below a given threshold.
Here is a list of possible assertion checks for a FIFO design:
			- a FIFO is never written into when full: Check that there is no FIFO overflow,
			- a FIFO is never read when empty: Check that there is no FIFO underflow,
			- a FIFO preserves the data order,
			- a FIFO preserves the data value.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_04300.svg" height="250px" width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04400">
		<hb:RuleUID>STD_04400</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Clock management module</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>A dedicated clock module is essential to design for reuse and design portability, while improving clocks identification and management throughout the design.
Such a practice isolates all vendor-specific clocking	elements such as PLLs, clock multiplexers and clock buffers in a single instance that can be easily replaced to target another technology from the same vendor or not. Thereby, a FPGA prototype design can be easily ported to another FPGA family or an ASIC technology.</hb:Rationale>
			<hb:ShortDesc>All global clocks are generated in a single dedicated module.</hb:ShortDesc>
			<hb:LongDesc>Any clock element inserted in any clock path is instantiated inside the same design entity. Clock elements are clock buffers, clock multiplexers, PLLs, DCMs, fractional dividers, gapped clock logic, enabled clock logic...</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample></hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_04400.svg" height="400px" width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04500">
		<hb:RuleUID>STD_04500</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2015-02-17</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of Clock Reassignment</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Reassignement of clock signal can lead to simulation mismatch regarding the Place and Route design. Search for simulation and delta cycle topic.</hb:Rationale>
			<hb:ShortDesc>Do not reassign a clock in a concurrent statement.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Trivial</hb:RemediationEffort>
			<hb:SonarTag>Bug</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_04500_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_04500_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_04500_bad.vhd</hb:BadExDesc>
			<hb:BadExample>STD_04500_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04600">
		<hb:RuleUID>STD_04600</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Clock domain number in the design</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>FPGA</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Reducing the number of clock domain in a design is critical in order to keep the number of clock domain crossing resolutions to few manageable cases.
Doing so limits the chance for clock domain crossing design issues, limits the number of nets not covered with static timing analysis and simplifies greatly the synthesis scripts.
For those reasons, usage of a single clock domain is strongly recommended.</hb:Rationale>
			<hb:ShortDesc>One clock domain is used in the design.</hb:ShortDesc>
			<hb:LongDesc>The number of timing domain is reduced as far as reasonably possible : one single clock domain design is the target.
When a slower clock version is needed, use an enable signal instead of a derived clock to throttle the resulting clock rate.
When a faster clock version is needed, promote that faster clock as the single clock domain used if the design and or re-design consequences are not prohibitive prior to creating a derived clock domain.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Suspicious</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure fileref="STD_04600.svg" height="450px" width="450px" />
		</hb:RuleDesc>
		<hb:RuleParams>
			<hb:IntParam>
				<hb:ParamID>P1</hb:ParamID>
				<hb:Relation>LET</hb:Relation>
				<hb:Value>1</hb:Value>
			</hb:IntParam>
		</hb:RuleParams>
	</hb:Rule>
	
	<hb:Rule UID="STD_04700">
		<hb:RuleUID>STD_04700</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Number of clock domains per modules</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>FPGA</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Separating the clock domains in the design architecture greatly improves the clock domains identifications, the data flow understanding and most importantly allows fast tracing of the clock domain crossing signals that need special design and static timing analysis considerations while allowing better design reuse.</hb:Rationale>
			<hb:ShortDesc>Each module in the design handle only one clock.</hb:ShortDesc>
			<hb:LongDesc>Entity that is linked between entities can have several clocks at input but do not manage processes on those clocks.
The only module that can handle several clocks are the clock management module and the reset management module.
Other modules can include different clocks but the data exchange between them is done through the approved clock domain crossing module.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Suspicious</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
		<hb:RuleParams>
			<hb:IntParam>
				<hb:ParamID>P1</hb:ParamID>
				<hb:Relation>LET</hb:Relation>
				<hb:Value>1</hb:Value>
			</hb:IntParam>
		</hb:RuleParams>
	</hb:Rule>
	
	<hb:Rule UID="STD_04800">
		<hb:RuleUID>STD_04800</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Clock edge sensitivity</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>FPGA</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Clocking</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Usage of a single clock sensitive edge allows efficient timing analysis.
				Using only one edge of a clock allows to avoid over-constraining static timing analysis. Moreover, the design isn't duty cycle sensitive.
			</hb:Rationale>
			<hb:ShortDesc>An unique single sensitive edge is used to clock all flip-flop in the same clock domain.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_04900">
		<hb:RuleUID>STD_04900</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Edge detection best practice</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Synchronous</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Flip-Flops clock input is dedicated to a clock signal. Thus, using it as a way to detect a signal edge (by using rising_edge(...) or 'event attribute) may lead to the creation of a new clock domain for each signal edge detection implemented in the design: this is not the purpose.</hb:Rationale>
			<hb:ShortDesc>Synchronous mechanisms are used for signal edge detection.</hb:ShortDesc>
			<hb:LongDesc>A specific mechanism is used in order to detect rising or falling edge input signal.
This mechanism involves a real design clock, at least one D Flip-Flop to delay the signal, and combinational gate(s) to select the edge.
			</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_04900_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_04900_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample></hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_04900.svg" height="450px" width="480px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05000">
		<hb:RuleUID>STD_05000</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Sensitivity list for synchronous processes</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Synchronous</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Synchronous process with any extra signals added to sensitivity list may become asynchronous.
Moreover, this practice risks adding combinational blocks on clock and reset trees.</hb:Rationale>
			<hb:ShortDesc>A synchronous process needs only the clock and reset signals in its sensitivity list.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_05000_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_05000_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_05000_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_05000_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05100">
		<hb:RuleUID>STD_05100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Metastability management</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Synchronous</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Synchronizing each asynchronous input signal to each clock domain where it is used is critical in order to guaranty a proper behaviour of the design under any circumstances. Thus, an asynchronous signal is synchronized to the clock domain where it is used using a two or three Flip-Flops synchronizer.
Doing so ensures that all the Flip-Flops of the sampling timing domain samples the very same value of a given asynchronous signal, as this techniques resolves the metastability issue, caused by setup or hold time violations, at the synchronizer level.
Not doing so causes issues in Finite State Machines. For example, the FSM can see the condition to exit a state true while the condition to enter the next state may still be seen false. This might lead the FSM to a wrong state transition. In the case of one hot state encoded FSMs this issue may cause the FSM to have no more active state which causes the FSM to fail.</hb:Rationale>
			<hb:ShortDesc>Asynchronous input signals are synchronized with at least a two Flip-Flops synchronizer.</hb:ShortDesc>
			<hb:LongDesc>Asynchronous inputs signals are defined as the following : 
signals generated without clock and signals generated in another time domain.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Pittfall</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_05100_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_05100_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_05100.svg" height="150px"
				width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
		
	<hb:Rule UID="STD_05200">
		<hb:RuleUID>STD_05200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>Yosys-ghdl</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Output signal registration</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Synchronous</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>All outputs of an integrated circuit are coming from output registers whenever possible and from regular registers when not possible. The clock used is the same as the one used in the signal source clock domain.
Doing so suppresses all glitches on the outputs	whenever a signal level change occurs and enables control of the clocks to outputs delays of the circuit so that the time borrowed by any signal to propagate from its respective launching clock edge to its assigned device output is controlled and less than a given maximum allowed time.
With controlled clocks to outputs delays, enough PCB propagation time and inputs to clocks delays is left for those outputs to be captured using the same clock in a remote device.</hb:Rationale>
			<hb:ShortDesc>All outputs signal from a top level entity are registered.</hb:ShortDesc>
			<hb:LongDesc>Combinational outputs at top level are forbidden. Those outputs belong to the timing domain in which they are generated at top level. Whenever it is possible, use I/O blocks register instead of internal register for top level outputs.
Unless specified and approved, a combinational signal is never used directly as a top level output.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_05200.svg" height="450px"
				width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05300">
		<hb:RuleUID>STD_05300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Sensitivity list for combinational processes </hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Combinational</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>If an input signal is missing in the sensitivity list, there might be a mismatch between VHDL simulation and the programmed FPGA matrix.</hb:Rationale>
			<hb:ShortDesc>Combinational processes have a sensitivity list including all inputs signals which are read.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_05300.svg" height="450px"
				width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05400">
		<hb:RuleUID>STD_05400</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of internal tristate</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Combinational</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Best design practices call for design reuse. Inferring internal tristate goes against it as not every FPGA and every ASIC include this functionality.
For that reason, it is prohibited.</hb:Rationale>
			<hb:ShortDesc>Internal tristates drivers are forbidden in VLSI.</hb:ShortDesc>
			<hb:LongDesc>When an internal tristate solution would satisfy the functionality to model, use a multiplexer-based solution instead.
Do not hesitate to pipeline the structure according to the targeted clock frequency and targeted technology.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample></hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_05400.svg" height="400px" width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05500">
		<hb:RuleUID>STD_05500</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of latches</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Combinational</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Inferring latches in synchronous designs is not a good design practice. Even though a behavioural simulation shows that the design simulates correctly, it is only after a great deal of effort in synthesis, place and route, static timing analysis, and even back annotated simulations that the design executes correctly on the targeted technology. This is because of the clock and signals timing delays which very easily lead to a data crossing two latches at once when only one at once is desired.</hb:Rationale>
			<hb:ShortDesc>The design does not use latches on purpose.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_05500_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_05500_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_05500_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_05500_bad</hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_05500.svg" height="600px"
				width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05600">
		<hb:RuleUID>STD_05600</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of combinational feedbacks</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Combinational</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Inferring Combinatorial feedbacks is not a good design practice. Even though a behavioural simulation shows that the design simulates correctly, there is no guaranty that the design works properly on the targeted component. 
Indeed, at every step of the way through the backend, the timing loops provoked by these combinatorial feedbacks are broken so that the tool can proceed further. With doing so, all of the timing arcs passing through those combinatorial feedbacks are not analyzed, leaving room for all sorts of timing violations thus a non working component.</hb:Rationale>
			<hb:ShortDesc>The design does not use combinatorial feedback.</hb:ShortDesc>
			<hb:LongDesc>When synthesis reports that a timing loop is broken in a combinational process, check your design for asynchronous signals appearing on both sides of a combinational assignment statement. Once isolated break the timing loop.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_05600_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_05600_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_05600_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_05600_bad</hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_05600.svg" height="300px"
				width="450px" />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05700">
		<hb:RuleUID>STD_05700</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of gated clocks</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>FPGA</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Combinational</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Clock gating objective is to reduce the power consumption of a synchronous design. Freezing the clock reduce the power consumption from transistors toggle and clock tree propagation. This great power saving comes at the expense of the design of the gated clock logic, which can be easily implemented with dedicated gates inside an ASIC but might not be available inside a FPGA.
Thus, gated clock usage is prohibited inside FPGA.</hb:Rationale>
			<hb:ShortDesc>The design does not use gated clock.</hb:ShortDesc>
			<hb:LongDesc>Intentionally inferring gated clock in FPGA is prohibited; use the Flip-Flops clock enable instead.
When the synthesis reports that a gated clock was created, turn off the synthesis tool "auto convert gated clock" option, so that the tool uses the Flip-Flops clock enable instead.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_05700_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_05700_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_05700_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_05700_bad</hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure fileref="STD_05700.svg" height="300px"
				width="450px" ></hb:Figure>
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_05800">
		<hb:RuleUID>STD_05800</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Use of VHDL types in RTL design</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Type</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>VHDL language provides many different types. These types do not all have a physical match with a physical component. Some of them are only used in simulation.</hb:Rationale>
			<hb:ShortDesc>Only synthesizable types are allowed in RTL design.</hb:ShortDesc>
			<hb:LongDesc>Only the following types are allowed for RTL design : std_logic, std_logic_vector, integer, signed, unsigned and record/array of those.
Enumerate is allowed for FSMs and boolean for generics.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
		
	<hb:Rule UID="STD_05900">
		<hb:RuleUID>STD_05900</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Range for integers</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Type</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Usage of "range" keyword constrains synthesis optimization effort. It avoids mismatches between simulation and board.</hb:Rationale>
			<hb:ShortDesc>Integer type are constrained using the keyword "range".</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Suspicious</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_05900_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_05900_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_05900_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_05900_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06000">
		<hb:RuleUID>STD_06000</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Range direction for arrays</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Type</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>This is a convention to improve use of arrays.</hb:Rationale>
			<hb:ShortDesc>"Array" type declaration uses increasing index with "to" keyword.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_06000_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_06000_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc ></hb:FigureDesc>
			<hb:Figure ></hb:Figure>
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06100">
		<hb:RuleUID>STD_06100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Range direction for std_logic_vector</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Type</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>This is a convention to improve use of std_logic_vector.</hb:Rationale>
			<hb:ShortDesc>"Std_logic_vector" type declaration uses decreasing index with "downto" keyword.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Convention</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_06100_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_06100_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_06100_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_06100_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>

	<hb:Rule UID="STD_06200">
		<hb:RuleUID>STD_06200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Management of numeric values</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Type</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Using constant instead of hard coded numeric value inside the VHDL code improves the identification of these values. Thus, modification of these values (if needed) will be easier.</hb:Rationale>
			<hb:ShortDesc>Use VHDL constant as much as possible instead of hard coded numeric values.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_06200_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_06200_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_06200_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_06200_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06300">
		<hb:RuleUID>STD_06300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of variables in RTL design</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Type</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>VHDL signal is the object used to describe an electrical wire connection or a register. VHDL signal is the way to have a communication between VHDL processes, whereas variable were meant to store a value inside a VHDL process. A variable is assigned without any delay whereas signal assignment lead to an event after a delta delay. This difference can induce design errors or simulation and synthesis mismatch</hb:Rationale>
			<hb:ShortDesc>Variables are prohibited in the RTL design.</hb:ShortDesc>
			<hb:LongDesc>Only signal type is allowed in RTL design.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Info</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Suspicious</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample />
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06400">
		<hb:RuleUID>STD_06400</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Error mitigation strategy</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>Spatial</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Reliability</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Error mitigation can be made at VHDL design level. If it is expected to be done at this level, the mechanisms have to be approved.</hb:Rationale>
			<hb:ShortDesc>All mitigation mechanisms are done with a specific approved mechanism.</hb:ShortDesc>
			<hb:LongDesc>In order to mitigate errors due to radiation, mechanisms (EDAC, ECC, parity, srubbing, triplication...) can be implemented in the FPGA if needed.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Vulnerability</hb:SonarType>
			<hb:SonarSeverity>Critical</hb:SonarSeverity>
			<hb:RemediationEffort>Complex</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06500">
		<hb:RuleUID>STD_06500</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Counters end of counting</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>true</hb:IsSon>
			<hb:ParentUID>STD_06400</hb:ParentUID>
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Reliability</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>This feature allows the synthesizer to optimize the counter in a way that if the counted value pass over the final one the end of counter is still reached. The result of the synthesis can sometimes be more efficient than with the use of "=".</hb:Rationale>
			<hb:ShortDesc>Use non strict comparison (&lt;= and &gt;=) for end of counting comparison.</hb:ShortDesc>
			<hb:LongDesc>When comparing a cyclic counter value against its end of count value, non strict comparison is used instead of strict comparison.
For an up counter, use the greater than or equal to (&gt;=) comparison sign instead of the equals sign (=).
For a down counter, use the less than or equal (&lt;=) comparison sign instead of the equals sign (=).</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Vulnerability</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Major</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_06500_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_06500_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_06500_bad.vhd</hb:BadExDesc>
			<hb:BadExample >STD_06500_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06600">
		<hb:RuleUID>STD_06600</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2015-02-17</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Dimension of comparison elements</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Reliability</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Comparison of two std_logic_vector signal of different size can lead to unexpected result.</hb:Rationale>
			<hb:ShortDesc>Two comparison elements must have the same type and dimension.</hb:ShortDesc>
			<hb:LongDesc>Using of unsigned or signed type to insure comparison between two elements is a best practice.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Unpredictable</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_06600_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_06600_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_06600_bad.vhd</hb:BadExDesc>
			<hb:BadExample>STD_06600_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06700">
		<hb:RuleUID>STD_06700</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of wait statement in RTL design</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Miscellaneous</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>"Wait" instructions and "after" clauses are forbidden inside the RTL design because they are not synthesizable.</hb:Rationale>
			<hb:ShortDesc>The "wait" statement and "after" clause are forbidden in RTL design.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Bug</hb:SonarType>
			<hb:SonarSeverity>Blocker</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc></hb:GoodExDesc>
			<hb:GoodExample ></hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06800">
		<hb:RuleUID>STD_06800</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Implemented</hb:Status>
			<hb:Engine>ZamiaCad</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of signal initialization in declaration section</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Miscellaneous</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Signals default value, in declaration section, is usually not synthesizable.</hb:Rationale>
			<hb:ShortDesc>Signals are never initialized to a default value when declared.</hb:ShortDesc>
			<hb:LongDesc>Signals are not initialized to a default value in declaration level but only during a reset sequence.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Major</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Suspicious</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_06800_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_06800_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_06800_bad.vhd</hb:BadExDesc>
			<hb:BadExample>STD_06800_bad</hb:BadExample>
			<hb:FigureDesc></hb:FigureDesc>
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_06900">
		<hb:RuleUID>STD_06900</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Unsuitability of procedures and functions in RTL design</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Miscellaneous</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>VHDL provide synthesizable object (Process and Component) to structure and replicate statements.
Procedures and functions are not provided for synthesis approach but for testbench development.
			</hb:Rationale>
			<hb:ShortDesc>Procedures and functions are forbidden in RTL design.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Suspicious</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_07000">
		<hb:RuleUID>STD_07000</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>3</hb:Version>
			<hb:Creation>2015-02-17</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Maximum depths of nested objects</hb:Name>
			<hb:IsParent>true</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Design</hb:Category>
			<hb:SubCategory>Miscellaneous</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Nested objects limited in depth improves understanding of project and keep modules less complicated.</hb:Rationale>
			<hb:ShortDesc>Nested VHDL objects are limited in depth.</hb:ShortDesc>
			<hb:LongDesc>The depth of nested objects (entities, packages, dimensions) should be kept limited.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>High</hb:RemediationEffort>
			<hb:SonarTag>Design</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_07100">
		<hb:RuleUID>STD_07100</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>5</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Simulation ending</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Simulation</hb:Category>
			<hb:SubCategory>Miscellaneous</hb:SubCategory>
			<hb:Severity>Major</hb:Severity>
			<hb:Rationale>Limited duration for testbenches avoid useless simulation runs (beyond stimulus range) thus freeing machine resources for other designers. This allows the automatic sequencing of testbenches (during non regression tests for instance).</hb:Rationale>
			<hb:ShortDesc>The simulation duration is terminated by an automatic mechanism.</hb:ShortDesc>
			<hb:LongDesc>The simulation stop automatically without any human action in the simulator. This can be done by external scripts, event starvation (like freezing the main clocks) in the testbench.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Minor</hb:SonarSeverity>
			<hb:RemediationEffort>Easy</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_07100_good.vhd</hb:GoodExDesc>
			<hb:GoodExample>STD_07100_good</hb:GoodExample>
			<hb:BadExDesc>Extracted from STD_07100_bad.vhd</hb:BadExDesc>
			<hb:BadExample>STD_07100_bad</hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_07200">
		<hb:RuleUID>STD_07200</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>4</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Use of procedures and functions in testbenches</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Simulation</hb:Category>
			<hb:SubCategory>Miscellaneous</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Testbenches are not made to be synthesized. Thus, not synthesizable VHDL features can be used inside testbenches.
Functions and procedures in testbenches ensure saving time of development. 
Moreover, the testbench is more compact because identical instructions aren't repeated, which ensures better understanding and reduces the error number.</hb:Rationale>
			<hb:ShortDesc>Procedures and functions are recommended in testbenches.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Info</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc />
			<hb:GoodExample />
			<hb:BadExDesc />
			<hb:BadExample />
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>
	
	<hb:Rule UID="STD_07300">
		<hb:RuleUID>STD_07300</hb:RuleUID>
		<hb:RuleHist>
			<hb:Status>Validated</hb:Status>
			<hb:Engine>None</hb:Engine>
			<hb:Version>6</hb:Version>
			<hb:Creation>2014-09-30</hb:Creation>
			<hb:Modified>2020-04-23</hb:Modified>
			<hb:Revision>Not used anymore.See Git logs.</hb:Revision>
		</hb:RuleHist>
		<hb:RuleContent>
			<hb:Name>Use of wait statement in testbenches</hb:Name>
			<hb:IsParent>false</hb:IsParent>
			<hb:IsSon>false</hb:IsSon>
			<hb:ParentUID xsi:nil="true" />
			<hb:Technology>VLSI</hb:Technology>
			<hb:ApplicationFields>General</hb:ApplicationFields>
			<hb:Category>Simulation</hb:Category>
			<hb:SubCategory>Miscellaneous</hb:SubCategory>
			<hb:Severity>Minor</hb:Severity>
			<hb:Rationale>Use of "wait" statement or "after" clause free the designer from maintaining a process sensitivity list while developing a testbench (sensitivity list is empty when a "wait" is used inside a process).
The testbench instructions inside a process are then sequential which is coherent with most testbench stimulation sequences.</hb:Rationale>
			<hb:ShortDesc>Testbenches are scheduled with "wait" instruction and "after" clause instead of combinational process.</hb:ShortDesc>
			<hb:LongDesc>No additional information.</hb:LongDesc>
		</hb:RuleContent>
		<hb:Sonarqube>
			<hb:SonarType>Code_Smell</hb:SonarType>
			<hb:SonarSeverity>Info</hb:SonarSeverity>
			<hb:RemediationEffort>Medium</hb:RemediationEffort>
			<hb:SonarTag>Bad-practice</hb:SonarTag>
		</hb:Sonarqube>
		<hb:RuleDesc>
			<hb:GoodExDesc>Extracted from STD_07300_good.vhd</hb:GoodExDesc>
			<hb:GoodExample >STD_07300_good</hb:GoodExample>
			<hb:BadExDesc></hb:BadExDesc>
			<hb:BadExample ></hb:BadExample>
			<hb:FigureDesc />
			<hb:Figure />
		</hb:RuleDesc>
	</hb:Rule>

	<hb:RuleSetHist>
		<hb:Version>7</hb:Version>
		<hb:Creation>2014-09-30</hb:Creation>
		<hb:Modified>2020-07-23</hb:Modified>
		<hb:Revision>V1 : 2014-11-13 : Creation.
V2   : 2014-12-01 : Update of rules with remarks from partners about V1 revision, rules have been transferred to CNES handbook.
V3   : 2015-02-17 : Update of rules with remarks from partners about V2 revision
V4   : 2015-07-16 : Update of rules with examples
V4.1 : 2015-11-18 : Correct several data from remarks
V5   : 2017-11-24 : Creation of Sonarqube data and update of some status
V6   : 2020-04-23 : Put implemented status for rules in software, remove revision for rules, complete Sonarqube fields.
V7   : 2020-07-23 : update engine feature
		</hb:Revision>
	</hb:RuleSetHist>	
</hb:RuleSet>
